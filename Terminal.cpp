#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
#include <deque>
#include <ctime>
 
using namespace std;

deque<string> historique5; //deque locale qui contiendra les 5 dernièrs commandes entrées
static int instance = 0; //numéro instance

//Fonction qui permet la mise à jour de l'historique basé sur les 5 dernieres commandes
void majhisto(string commandegenerer, string pid){
    if (historique5.size() < 5) //SI la taille est moins que 5, suffit d'ajouter la commande à la liste
    {
        historique5.push_back(commandegenerer + "\t" + pid);
    }
    else //SINON, il faut supprimer une commande (la première qui est arrivé) et ajouter la nouvelle
    {
        historique5.push_back(commandegenerer + "\t" + pid);
        historique5.pop_front();
    }
}

//Cette fonction permet l'affichage de l'historique
void afficherhisto(string nomhistorique) {
    ofstream historique; //Fichier en écriture pour l'historique
    historique.open(nomhistorique); //Permet l'ouverture du bon fichier .txt
    int numero = 5; //Entier qui sera en fait le numéro de la commande, commencant par 5

    //Premierement, si l'historique ne s'ouvre pas, il faut arrêter l'execution
    if (historique.fail())
    {
        cout << "Erreur lors de l'ouverture du fichier de l'historique." << endl;
    }
    else
    {
        //Sinon on peut commencer par écrire tout en haut le type de donnée par colonne
        cout << "NUMERO" << "\t" << "COMMAND" << "\t" << "PID" << endl;
        historique << "NUMERO" << "\t" << "COMMAND" << "\t" << "PID" << endl;
        
        //On peut ensuite lire l'historique 5 qui est une variable générale et l'afficher sur le terminal et dans le fichier txt
        for (size_t i = 0; i < historique5.size(); i++)
        {
            cout << numero << "\t" << historique5[i] << endl;
            historique << numero << "\t" << historique5[i] << endl;
            numero--;
        }
    }
}

//Cette fonction permet de déclarer le bon fichier de l'historique (historique sans gencommande)
void afficherhisto(){
    string historique; //nom du fichier
    historique = ("Historique.txt"); //Permet la déclaration du bon fichier .txt
    afficherhisto(historique); //appelle de la fonction affichage
}

//Cette fonction permet de déclarer le bon fichier de l'historique (historique avec gencommande)
void afficherhisto(int count){
    string historique; //nom du fichier
    historique = ("historique" + to_string(instance) + "_" + to_string(count) + ".txt"); //Permet la déclaration du bon fichier .txt
    afficherhisto(historique); //appelle de la fonction affichage
}

//Cette fonction permet d'executer la commande demander par la fonction de generation automatique
pid_t executecommand(char command[200]){
    //Pour executer une commande, il faut d'abord vérifier si la commande n'est pas = à 0
    if(strlen(command) != 0)
    {
        vector<char*>args; //L'argument sera ensuite transformé en vecteur
        char* prog = strtok(command, " "); //Prog est la partie avant l'espace (ls, mkdir, etc)
        char* tmp = prog; //Un char temporaire pour de futures manipulations. Il sera égale à prog pour l'instant.

        while ( tmp != NULL ) //Cette boucle permet d'empêcher des problèmes si il n'y aurait pas de commande entré.
        {
            args.push_back( tmp );
            tmp = strtok( NULL, " " );
        }    

        char** argv = new char*[args.size()+1]; //Nouvelle variable argv (array de même taille +1 que args)

        //Boucle permettant le transfert de args à la variable argv
        for ( int k = 0; k < args.size(); k++ )
        {
            argv[k] = args[k];
        }

        argv[args.size()] = NULL; //Le dernier char de l'argument devra être nulle pour ne pas créer d'erreur (à cause du enter à la fin)

        pid_t kidpid = fork(); //Fork qui permet de créer l'enfant qui éxecutera la commande

        //SI le kidpid est plus petit que 0, il y a eu une erreur
        if(kidpid < 0)
        {
            perror("Could not fork");
        }
        //SINON si c'est égale à 0, c'est l'enfant alors il execute la commande
        else if (kidpid == 0)
        {
            execvp(prog,argv);
        }
        else //Partie qui appartient au parent
        {
            if(waitpid(kidpid,0,0) <0 )
            {
            return kidpid;
            }
        }
        return kidpid; //Retourne le pid de l'enfant qui a execute la commande
        delete tmp, args, argv, prog; //Libération de mémoire après le processus d'execution
    }
}

//Cette fonction permet de génerer un nombre de commandes automatiquement et les execute par la fonction précedente
void gencommande(int nbcommandes, int nbhisto){
    ofstream historique; //Fichier en écriture pour l'historique totale
    historique.open("historiqueTOTALE" + to_string(instance) + "_" + to_string(nbcommandes) + ".txt"); //Ouverture du fichier.txt de l'historique TOTALE

    srand(static_cast<unsigned>(time(0))); //Permet d'initialiser le temps (pour que la fonction rand() fonctionne)
    int count = 0; //Permet d'initiliser le compteur qui sera utile pour déterminer le moment où la boucle sera terminé
    int numerocommande; //Numéro de la commande, sera utile afin de générer les commandes

    string commandgenerer; //Contiendra la commande qui a été génerer
    pid_t pid; //Permettra de récuper le pid de l'enfant qui executera la commande

    //Vecteur des commandes possibles (possibilité de modifier et ajouter des commandes)
    vector<string> commandespossibles = {"ls", "ls -l", "pwd", "man", "mkdir test", "mkdir test2", "rmdir test", 
    "rmdir test2", "rmdir test3", "mv test test1", "mv test3 test4", "cat Lire.txt"};

    char command[200]; //Variable char pour la command

    if (historique.fail())
    {
        /* ERREUR */
    }
    else
    {
        //En-tête du fichier historique gen auto
        historique << "COMMAND" << "\t" << "PID" << endl;

        while (count < nbcommandes) //Tant que le count n'est pas = au nombre de commandes à génerer
        {
            numerocommande = rand() % commandespossibles.size(); //Gen aléatoire de nombres de 0 au nombre de commandes possibles.
            commandgenerer = commandespossibles[numerocommande]; //La commande qui est généré sera donc la commande du numéro générer aléatoirement du vecteur commandespossibles
            strcpy(command, commandgenerer.c_str()); //Copie de la commandegenere en char pour le transfert à la fonction d'execution
            cout << "RababBOULKRIATSamuelBRASSARDTomJAMMES< " << command << endl; //Affiche au terminal les noms avant la commande
            pid = executecommand(command); //Execution de la commande
            historique << commandgenerer << "\t" << to_string(pid) << endl; //maj de l'historique genauto
            majhisto(commandgenerer, to_string(pid)); //maj de l'historique de 5

            //Appel de la commande afficher historique (avec le numéro du count) aux multiples du nombres entrer en parametre
            if (count % nbhisto == 0 & count != 0)
            {
                afficherhisto(count);
            }

            count++; //Incrémentation du count
        }

        //Appel de la commande afficher historique (ajouter à la fin s'il y a lieu)
        if (count % nbhisto == 0)
        {
            afficherhisto(count);
        }
    }
}

/*****************************************************MAIN*****************************************************/
int main()
{   
    string commandehisto; //Permettra de transferer la command char en commande string pour envoyer à l'historique
    string commandeverif; //Permettra la vérification de la commande
    char command[200]; //variable char pour la commande entrée
    bool erreur; //bool qui permettra de gérer si la commande entrée est une commande valide ou non
    clock_t t; //variable pour le temps d'execution
    int nbcommandes; //variable pour le nb de commandes a generer
    int nbinstance; //variable pour le nb d'historique a generer

    //Vecteur des commandes possibles
    vector<string> commandespossibles = {"ls", "pwd", "man", "mkdir", "rmdir", "mv", "cat", "stop", "historique", "gencommande"};

    while(true) //Le while ici permet de créer une boucle afin que la lecture de commande continue même après la première commande.
    {   
        std::cout << "RababBOULKRIATSamuelBRASSARDTomJAMMES< ";
        cin.getline(command,200); //Récupération de la commande entrée
        commandehisto = command;
        erreur = true; //Initialisation de erreur à true

        //Pour executer une commande, il faut d'abord vérifier si la commande n'est pas = à 0
        if(strlen(command) != 0)
        {
            vector<char*>args; //L'argument sera ensuite transformé en vecteur
            char* prog = strtok(command, " "); //Prog est la partie avant l'espace (ls, mkdir, etc)
            char* tmp = prog; //Un char temporaire pour de futures manipulations. Il sera égale à prog pour l'instant.

            while ( tmp != NULL ) //Cette boucle permet d'empêcher des problèmes si il n'y aurait pas de commande entré.
            {
                args.push_back( tmp );
                tmp = strtok( NULL, " " );
            }    

            char** argv = new char*[args.size()+1]; //Nouvelle variable argv (array de même taille +1 que args)

            //Boucle permettant le transfert de args à la variable argv
            for ( int k = 0; k < args.size(); k++ )
            {
                argv[k] = args[k];
            }
            
            commandeverif = command; //permet de transferer la commande en string pour faire les vérifications
            //Boucle pour vérifier que la commande est une commande valide
            for (int i = 0; i < commandespossibles.size(); i++)
            {
                if (commandeverif == commandespossibles[i] || commandeverif == commandespossibles[i] + "&") //SI la commande est égale à une des commandes possibles, alors erreur est faux.
                {
                    erreur = false;
                    break;
                }
            }

            if (prog[0] == '.') //cependant, si prog[0] est un point, ce ne sera pas une commande mais ca reste valide
            { 
                erreur = false;
            }

            argv[args.size()] = NULL; //Le dernier char de l'argument devra être nulle.

            if ( strcmp( command, "stop" ) == 0) //SI la commande stop est entrée, il faut arrêter l'execution ici.
            {
                return 0;
            }
            //SI la commande était historique, alors il faut executer l'historique.
            else if (strcmp( command, "historique" ) == 0)
            {
                afficherhisto();
                majhisto(commandehisto, to_string(getpid()));
            }
            else if (strcmp( command, "gencommande" ) == 0) //gencommande sera la commande pour des commandes automatiques
            {
                if (args[1] == NULL || args [2] == NULL) //Deux arguments doivent être entrés donc verification
                {   
                    cout << "ERREUR dans l'ecriture de la commande." << endl << "Syntaxe correct : gencommande [nb de commandes a generer] [historique au nb de commande]" << endl;
                    
                }
                else
                {
                    instance ++; //incrémentation instance
                    nbcommandes = stoi(args[1]); //Transformation en int des variable dans args
                    nbinstance = stoi(args[2]);
                    majhisto(commandehisto, to_string(getpid()));
                    t = clock(); //Début de la mesure du temps d'execution
                    gencommande(nbcommandes, nbinstance); //appel de la fonction gencommande
                    t = clock() - t; //Mesure du temps d'execution
                    cout << "temps d'execution: " << t << "ms" << endl; //affichage du temps d'execution
                }
            }
            else if (erreur) //Else if ici pour vérifier que la commande est valide (GESTION ERREUR)
            {
                cout << "Commande invalide, veuillez entrez une commande valide !" << endl;
            }
            else
            {
                //SI la commande commence par un ".", il faudra éxecuter une application.
                if(prog[0] == '.')
                {        
                    std::system(args[0]);
                    majhisto(commandehisto, to_string(getpid())); //maj de l'historique
                }
                else
                {
                    pid_t kidpid = fork(); //Fork qui permet de créer l'enfant qui éxecutera la commande

                    //SI le kidpid est plus petit que 0, il y a eu une erreur
                    if(kidpid < 0)
                    {
                        perror("Could not fork");
                        return -1;
                    }
                    //SINON si c'est égale à 0, c'est l'enfant alors il execute la commande
                    else if (kidpid == 0) //Partie qui appartient à l'enfant (fork)
                    {
                        execvp(prog,argv);
                    }
                    else //Partie qui appartient au parent
                    {
                        majhisto(commandehisto, to_string(kidpid)); //maj de l'historique
                        
                        if(waitpid(kidpid,0,0) <0 )
                        {
                            return -1;
                        }
                    }
                    delete tmp, args, argv, prog; //Libération de mémoire après le processus d'execution
                }
            }
        }
    }
    return 0;     
}